<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>node的使用 | 写点东西试试</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="node 全局变量在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。
在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。
global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条">
<meta property="og:type" content="article">
<meta property="og:title" content="node的使用">
<meta property="og:url" content="http://hongdaorongthink.github.io/2016/07/21/node的使用/index.html">
<meta property="og:site_name" content="写点东西试试">
<meta property="og:description" content="node 全局变量在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。
在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。
global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条">
<meta property="og:image" content="http://hongdaorongthink.github.io/./image/nodejs-require.jpg">
<meta property="og:updated_time" content="2016-08-08T02:56:26.808Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="node的使用">
<meta name="twitter:description" content="node 全局变量在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。
在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。
global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条">
<meta name="twitter:image" content="http://hongdaorongthink.github.io/./image/nodejs-require.jpg">
  
    <link rel="alternate" href="/atom.xml" title="写点东西试试" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">写点东西试试</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">胆大点、心细点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hongdaorongthink.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-node的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/21/node的使用/" class="article-date">
  <time datetime="2016-07-21T12:54:24.000Z" itemprop="datePublished">2016-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      node的使用
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="node-全局变量"><a href="#node-全局变量" class="headerlink" title="node 全局变量"></a>node 全局变量</h1><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量： </p>
<ul>
<li>最外层定义的变量；</li>
<li>全局对象的属性；</li>
<li>隐式定义的变量（未定义直接赋值的变量）。</li>
</ul>
<p>当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</p>
<p>注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。</p>
<h2 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h2><h2 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h2><h2 id="setTimeout-cb-ms"><a href="#setTimeout-cb-ms" class="headerlink" title="setTimeout(cb, ms)"></a>setTimeout(cb, ms)</h2><h2 id="clearTimeout-t"><a href="#clearTimeout-t" class="headerlink" title="clearTimeout(t)"></a>clearTimeout(t)</h2><h2 id="setInterval-cb-ms"><a href="#setInterval-cb-ms" class="headerlink" title="setInterval(cb, ms)"></a>setInterval(cb, ms)</h2><h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道</p>
<p><strong>__filename</strong> 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。 </p>
<blockquote>
<p>  // 输出全局变量 <strong>filename 的值<br>    console.log( </strong>filename );<br>    // 输出全局变量 <strong>dirname 的值<br>    console.log( </strong>dirname );<br>    setTimeout(cb, ms)<br>    clearTimeout(t)<br>    setInterval(cb, ms)<br>    console<br>    process 提供了很多方法<br>        process.on(‘exit’, function(code) {<br>        // 以下代码永远不会执行<br>        setTimeout(function() {<br>            console.log(“该代码不会执行”);<br>        }, 0);<br>        console.log(‘退出码为:’, code);<br>        });<br>        console.log(“程序执行结束”);  </p>
</blockquote>
<h1 id="怎么用-require"><a href="#怎么用-require" class="headerlink" title="怎么用 require"></a>怎么用 require</h1><p><img src="./image/nodejs-require.jpg" alt="alt"></p>
<p><strong>exports</strong> 对象会为外部所用</p>
<p>module.exports才是真正的接口，exports只不过是它的一个辅助工具</p>
<h1 id="node-事件机制"><a href="#node-事件机制" class="headerlink" title="node 事件机制 "></a>node 事件机制 </h1><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
<h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><ul>
<li>events 模块只提供了一个对象： <code>events.EventEmitter</code>。<br>  EventEmitter 的核心就是事件触发与事件监听器功能的封装。<br>  你可以通过 <code>require(&quot;events&quot;);</code> 来访问该模块。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//event.js 文件</span></div><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </div><div class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter(); </div><div class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span>); </div><div class="line">&#125;); </div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    event.emit(<span class="string">'some_event'</span>); </div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="node-处理二进制"><a href="#node-处理二进制" class="headerlink" title="node 处理二进制"></a>node 处理二进制</h1><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>
<p>但在处理像TCP流或文件流时，必须使用到二进制数据。<br>因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。<br>Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，<br>每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。<br>原始数据存储在 Buffer 类的实例中。<br>一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<blockquote>
<p>  var buf = new Buffer(10);<br>    var buf = new Buffer([10, 20, 30, 40, 50]);<br>    var buf = new Buffer(“www.runoob.com”, “utf-8”);<br>    utf-8 是默认的编码方式，此外它同样支持以下编码：”ascii”, “utf8”, “utf16le”, “ucs2”, “base64” 和 “hex”。<br>    写入<br>    buf.write(string[, offset[, length]][, encoding])<br>    读取<br>    buf.toString([encoding[, start[, end]]])<br>    buf.toJSON()<br>    Buffer.concat(list[, totalLength])<br>    buf.compare(otherBuffer);<br>    buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])  </p>
</blockquote>
<h1 id="node-处理流"><a href="#node-处理流" class="headerlink" title="node 处理流"></a>node 处理流</h1><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 </p>
<p>Node.js，Stream 有四种流类型：</p>
<ul>
<li>Readable - 可读操作。</li>
<li>Writable - 可写操作。</li>
<li>Duplex - 可读可写操作.</li>
<li>Transform - 操作被写入数据，然后读出结果。</li>
</ul>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li>data - 当有数据可读时触发。</li>
<li>end - 没有更多的数据可读时触发。</li>
<li>error - 在接收和写入过程中发生错误时触发。</li>
<li>finish - 所有数据已被写入到底层系统时触发。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"></div><div class="line"><span class="comment">// 创建可读流</span></div><div class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 设置编码为 utf8。</span></div><div class="line">readerStream.setEncoding(<span class="string">'UTF8'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></div><div class="line">readerStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">   data += chunk;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readerStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">readerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(err.stack);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">'菜鸟教程官网地址：www.runoob.com'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span></div><div class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 使用 utf8 编码写入数据</span></div><div class="line">writerStream.write(data,<span class="string">'UTF8'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 标记文件末尾</span></div><div class="line">writerStream.end();</div><div class="line"></div><div class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></div><div class="line">writerStream.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"写入完成。"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">writerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(err.stack);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</div></pre></td></tr></table></figure>
<h1 id="Node-js-常用工具"><a href="#Node-js-常用工具" class="headerlink" title="Node.js 常用工具"></a>Node.js 常用工具</h1><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。 </p>
<h1 id="util-inherits"><a href="#util-inherits" class="headerlink" title="util.inherits"></a>util.inherits</h1><p>util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。 </p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>); </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="keyword">this</span>.name = <span class="string">'base'</span>; </div><div class="line">	<span class="keyword">this</span>.base = <span class="number">1991</span>; </div><div class="line">	<span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name); </div><div class="line">	&#125;; </div><div class="line">&#125; </div><div class="line">Base.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;; </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="keyword">this</span>.name = <span class="string">'sub'</span>; </div><div class="line">&#125; </div><div class="line">util.inherits(Sub, Base); </div><div class="line"><span class="keyword">var</span> objBase = <span class="keyword">new</span> Base(); </div><div class="line">objBase.showName(); </div><div class="line">objBase.sayHello(); </div><div class="line"><span class="built_in">console</span>.log(objBase); </div><div class="line"><span class="keyword">var</span> objSub = <span class="keyword">new</span> Sub(); </div><div class="line">objSub.showName(); </div><div class="line"><span class="comment">//objSub.sayHello(); </span></div><div class="line"><span class="built_in">console</span>.log(objSub);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。<br>    同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。</p>
</blockquote>
<h2 id="util-inspect"><a href="#util-inspect" class="headerlink" title="util.inspect"></a>util.inspect</h2><p>util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。 </p>
<p>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。</p>
<p>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。</p>
<p>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。</p>
<h2 id="util-isArray-object"><a href="#util-isArray-object" class="headerlink" title="util.isArray(object)"></a>util.isArray(object)</h2><h2 id="util-isRegExp-object"><a href="#util-isRegExp-object" class="headerlink" title="util.isRegExp(object)"></a>util.isRegExp(object)</h2><h2 id="util-isDate-object"><a href="#util-isDate-object" class="headerlink" title="util.isDate(object)"></a>util.isDate(object)</h2><h2 id="util-isError-object"><a href="#util-isError-object" class="headerlink" title="util.isError(object)"></a>util.isError(object)</h2><h1 id="node-文件系统"><a href="#node-文件系统" class="headerlink" title="node 文件系统"></a>node 文件系统</h1><p>Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 Node 导入文件系统模块(fs)语法如下所示：</p>
<p><code>var fs = require(&quot;fs&quot;)</code></p>
<p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。</p>
<p>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。</p>
<p>建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = require(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 异步读取</span></div><div class="line">fs.readFile('<span class="keyword">input</span>.txt', function (<span class="keyword">err</span>, data) &#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</div><div class="line">       <span class="keyword">return</span> console.<span class="keyword">error</span>(<span class="keyword">err</span>);</div><div class="line">   &#125;</div><div class="line">   console.<span class="built_in">log</span>(<span class="string">"异步读取: "</span> + data.<span class="keyword">toString</span>());</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 同步读取</span></div><div class="line"><span class="keyword">var</span> data = fs.readFileSync('<span class="keyword">input</span>.txt');</div><div class="line">console.<span class="built_in">log</span>(<span class="string">"同步读取: "</span> + data.<span class="keyword">toString</span>());</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">"程序执行完毕。"</span>);</div></pre></td></tr></table></figure>
<ul>
<li><p>打开文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 异步打开文件</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</div><div class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (err) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">   &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);     </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>获取文件信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line">fs.stat(<span class="string">'/Users/liuht/code/itbilu/demo/fs.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(stats.isFile()); 		<span class="comment">//true</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>写入文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"准备写入文件"</span>);</div><div class="line">fs.writeFile(<span class="string">'input.txt'</span>, <span class="string">'我是通过写入的文件内容！'</span>,  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (err) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"数据写入成功！"</span>);</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"--------我是分割线-------------"</span>)</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"读取写入的数据！"</span>);</div><div class="line">   fs.readFile(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"异步读取文件数据: "</span> + data.toString());</div><div class="line">   &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>读取文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">1024</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开已存在的文件！"</span>);</div><div class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (err) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"准备读取文件："</span>);</div><div class="line">   fs.read(fd, buf, <span class="number">0</span>, buf.length, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span> (err)&#123;</div><div class="line">         <span class="built_in">console</span>.log(err);</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">console</span>.log(bytes + <span class="string">"  字节被读取"</span>);</div><div class="line">      </div><div class="line">      <span class="comment">// 仅输出读取的字节</span></div><div class="line">      <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</div><div class="line">         <span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>, bytes).toString());</div><div class="line">      &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>关闭文件</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = require(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> buf = new Buffer(1024);</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">"准备打开文件！"</span>);</div><div class="line">fs.<span class="keyword">open</span>('<span class="keyword">input</span>.txt', 'r+', function(<span class="keyword">err</span>, fd) &#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</div><div class="line">       <span class="keyword">return</span> console.<span class="keyword">error</span>(<span class="keyword">err</span>);</div><div class="line">   &#125;</div><div class="line">   console.<span class="built_in">log</span>(<span class="string">"文件打开成功！"</span>);</div><div class="line">   console.<span class="built_in">log</span>(<span class="string">"准备读取文件！"</span>);</div><div class="line">   fs.<span class="keyword">read</span>(fd, buf, 0, buf.length, 0, function(<span class="keyword">err</span>, bytes)&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">err</span>)&#123;</div><div class="line">         console.<span class="built_in">log</span>(<span class="keyword">err</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 仅输出读取的字节</span></div><div class="line">      <span class="keyword">if</span>(bytes &gt; 0)&#123;</div><div class="line">         console.<span class="built_in">log</span>(buf.slice(0, bytes).<span class="keyword">toString</span>());</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 关闭文件</span></div><div class="line">      fs.<span class="keyword">close</span>(fd, function(<span class="keyword">err</span>)&#123;</div><div class="line">         <span class="keyword">if</span> (<span class="keyword">err</span>)&#123;</div><div class="line">            console.<span class="built_in">log</span>(<span class="keyword">err</span>);</div><div class="line">         &#125; </div><div class="line">         console.<span class="built_in">log</span>(<span class="string">"文件关闭成功"</span>);</div><div class="line">      &#125;);</div><div class="line">   &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>截取文件</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = require(<span class="string">"fs"</span>);</div><div class="line"><span class="keyword">var</span> buf = new Buffer(1024);</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">"准备打开文件！"</span>);</div><div class="line">fs.<span class="keyword">open</span>('<span class="keyword">input</span>.txt', 'r+', function(<span class="keyword">err</span>, fd) &#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</div><div class="line">       <span class="keyword">return</span> console.<span class="keyword">error</span>(<span class="keyword">err</span>);</div><div class="line">   &#125;</div><div class="line">   console.<span class="built_in">log</span>(<span class="string">"文件打开成功！"</span>);</div><div class="line">   console.<span class="built_in">log</span>(<span class="string">"截取10字节后的文件内容。"</span>);</div><div class="line">   </div><div class="line">   <span class="comment">// 截取文件</span></div><div class="line">   fs.ftruncate(fd, 10, function(<span class="keyword">err</span>)&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">err</span>)&#123;</div><div class="line">         console.<span class="built_in">log</span>(<span class="keyword">err</span>);</div><div class="line">      &#125; </div><div class="line">      console.<span class="built_in">log</span>(<span class="string">"文件截取成功。"</span>);</div><div class="line">      console.<span class="built_in">log</span>(<span class="string">"读取相同的文件"</span>); </div><div class="line">      fs.<span class="keyword">read</span>(fd, buf, 0, buf.length, 0, function(<span class="keyword">err</span>, bytes)&#123;</div><div class="line">         <span class="keyword">if</span> (<span class="keyword">err</span>)&#123;</div><div class="line">            console.<span class="built_in">log</span>(<span class="keyword">err</span>);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// 仅输出读取的字节</span></div><div class="line">         <span class="keyword">if</span>(bytes &gt; 0)&#123;</div><div class="line">            console.<span class="built_in">log</span>(buf.slice(0, bytes).<span class="keyword">toString</span>());</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// 关闭文件</span></div><div class="line">         fs.<span class="keyword">close</span>(fd, function(<span class="keyword">err</span>)&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">err</span>)&#123;</div><div class="line">               console.<span class="built_in">log</span>(<span class="keyword">err</span>);</div><div class="line">            &#125; </div><div class="line">            console.<span class="built_in">log</span>(<span class="string">"文件关闭成功！"</span>);</div><div class="line">         &#125;);</div><div class="line">      &#125;);</div><div class="line">   &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除文件！"</span>);</div><div class="line">fs.unlink(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (err) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"文件删除成功！"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>创建目录</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"创建目录 /tmp/test/"</span>);</div><div class="line">fs.mkdir(<span class="string">"/tmp/test/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">   <span class="keyword">if</span> (err) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"目录创建成功。"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>读取目录</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"查看 /tmp 目录"</span>);</div><div class="line">fs.readdir(<span class="string">"/tmp/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</div><div class="line">   <span class="keyword">if</span> (err) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">   &#125;</div><div class="line">   files.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log( file );</div><div class="line">   &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>删除目录</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = require(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(<span class="string">"准备删除目录 /tmp/test"</span>);</div><div class="line">fs.<span class="keyword">rmdir</span>(<span class="string">"/tmp/test"</span>,function(<span class="keyword">err</span>)&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</div><div class="line">       <span class="keyword">return</span> console.<span class="keyword">error</span>(<span class="keyword">err</span>);</div><div class="line">   &#125;</div><div class="line">   console.<span class="built_in">log</span>(<span class="string">"读取 /tmp 目录"</span>);</div><div class="line">   fs.readdir(<span class="string">"/tmp/"</span>,function(<span class="keyword">err</span>, files)&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">err</span>) &#123;</div><div class="line">          <span class="keyword">return</span> console.<span class="keyword">error</span>(<span class="keyword">err</span>);</div><div class="line">      &#125;</div><div class="line">      files.<span class="keyword">forEach</span>( function (<span class="keyword">file</span>)&#123;</div><div class="line">          console.<span class="built_in">log</span>( <span class="keyword">file</span> );</div><div class="line">      &#125;);</div><div class="line">   &#125;);</div><div class="line">&#125;);</div><div class="line">```    </div><div class="line"></div><div class="line"></div><div class="line">node  获取 <span class="keyword">post</span> /get 请求</div><div class="line">================</div><div class="line">## 获取GET请求内容</div><div class="line"></div><div class="line">由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。 </div><div class="line"></div><div class="line">node.js中url模块中的<span class="keyword">parse</span>函数提供了这个功能。</div><div class="line"></div><div class="line"></div><div class="line">## 获取<span class="keyword">POST</span>请求内容</div><div class="line"></div><div class="line"><span class="keyword">POST</span>请求的内容全部的都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</div><div class="line"></div><div class="line">比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的<span class="keyword">POST</span>请求会大大消耗服务器的资源，所有node.js默认是不会解析请求体的， 当你需要的时候，需要手动来做。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>var http = require(‘http’);<br>var querystring = require(‘querystring’);<br>var util = require(‘util’);</p>
<p>http.createServer(function(req, res){<br>    var post = ‘’;     //定义了一个post变量，用于暂存请求体的信息</p>
<pre><code>req.on(&apos;data&apos;, function(chunk){    //通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    post += chunk;
});

req.on(&apos;end&apos;, function(){    //在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    post = querystring.parse(post);
    res.end(util.inspect(post));
});
</code></pre><p>}).listen(3000);</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="markdown"><span class="section">node  常用工具模块 </span></span></div><div class="line">==============</div><div class="line"><span class="section">## OS</span></div><div class="line"></div><div class="line"><span class="bullet">1. </span>os.tmpdir()</div><div class="line">返回操作系统的默认临时文件夹。 </div><div class="line"><span class="bullet">2. </span>os.endianness()</div><div class="line">返回 CPU 的字节序，可能的是 "BE" 或 "LE"。 </div><div class="line"><span class="bullet">3. </span>os.hostname()</div><div class="line">返回操作系统的主机名。 </div><div class="line"><span class="bullet">4. </span>os.type()</div><div class="line">返回操作系统名 </div><div class="line"><span class="bullet">5. </span>os.platform()</div><div class="line">返回操作系统名 </div><div class="line"><span class="bullet">6. </span>os.arch()</div><div class="line">返回操作系统 CPU 架构，可能的值有 "x64"、"arm" 和 "ia32"。 </div><div class="line"><span class="bullet">7. </span>os.release()</div><div class="line">返回操作系统的发行版本。 </div><div class="line"><span class="bullet">8. </span>os.uptime()</div><div class="line">返回操作系统运行的时间，以秒为单位。 </div><div class="line"><span class="bullet">9. </span>os.loadavg()</div><div class="line">返回一个包含 1、5、15 分钟平均负载的数组。 </div><div class="line"><span class="bullet">10. </span>os.totalmem()</div><div class="line">返回系统内存总量，单位为字节。 </div><div class="line"><span class="bullet">11. </span>os.freemem()</div><div class="line">返回操作系统空闲内存量，单位是字节。 </div><div class="line"><span class="bullet">12. </span>os.cpus()</div><div class="line">返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。 </div><div class="line"><span class="bullet">13. </span>os.networkInterfaces()</div><div class="line">获得网络接口列表。 </div><div class="line"></div><div class="line"></div><div class="line"><span class="section">## Path</span></div><div class="line"><span class="bullet">1. </span>path.normalize(p)</div><div class="line">规范化路径，注意'..' 和 '.'。 </div><div class="line"><span class="bullet">2. </span>path.join([<span class="string">path1</span>][<span class="symbol">, path2</span>][<span class="string">, ...</span>])</div><div class="line">用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是"/"，Windows系统是"\"。 </div><div class="line"><span class="bullet">3. </span>path.resolve([from ...], to)</div><div class="line">将 to 参数解析为绝对路径。 </div><div class="line"><span class="bullet">4. </span>path.isAbsolute(path)</div><div class="line">判断参数 path 是否是绝对路径。 </div><div class="line"><span class="bullet">5. </span>path.relative(from, to)</div><div class="line">用于将相对路径转为绝对路径。 </div><div class="line"><span class="bullet">6. </span>path.dirname(p)</div><div class="line">返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。 </div><div class="line"><span class="bullet">7. </span>path.basename(p[, ext])</div><div class="line">返回路径中的最后一部分。同 Unix 命令 bashname 类似。 </div><div class="line"><span class="bullet">8. </span>path.extname(p)</div><div class="line">返回路径中文件的后缀名，即路径中最后一个'.'之后的部分。如果一个路径中并不包含'.'或该路径只包含一个'.' 且这个'.'为路径的第一个字符，则此命令返回空字符串。 </div><div class="line"><span class="bullet">9. </span>path.parse(pathString)</div><div class="line">返回路径字符串的对象。 </div><div class="line"><span class="bullet">10. </span>path.format(pathObject)</div><div class="line">从对象中返回路径字符串，和 path.parse 相反。 </div><div class="line"></div><div class="line"></div><div class="line"><span class="section">## Net</span></div><div class="line"><span class="bullet">1. </span>net.createServer([<span class="string">options</span>][<span class="symbol">, connectionListener</span>])</div><div class="line">创建一个 TCP 服务器。参数 connectionListener 自动给 'connection' 事件创建监听器。 </div><div class="line"><span class="bullet">2. </span>net.connect(options[, connectionListener])</div><div class="line">返回一个新的 'net.Socket'，并连接到指定的地址和端口。</div><div class="line"> 当 socket 建立的时候，将会触发 'connect' 事件。 </div><div class="line"><span class="bullet">3. </span>net.createConnection(options[, connectionListener])</div><div class="line">创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 'localhost'。 </div><div class="line"><span class="bullet">4. </span>net.connect(port[<span class="string">, host</span>][<span class="symbol">, connectListener</span>])</div><div class="line">创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 'localhost'。参数 connectListener 将会作为监听器添加到 'connect' 事件。返回 'net.Socket'。 </div><div class="line"><span class="bullet">5. </span>net.createConnection(port[<span class="string">, host</span>][<span class="symbol">, connectListener</span>])</div><div class="line">创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 'localhost'。参数 connectListener 将会作为监听器添加到 'connect' 事件。返回 'net.Socket'。 </div><div class="line"><span class="bullet">6. </span>net.connect(path[, connectListener])</div><div class="line">创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 'connect' 事件上。返回 'net.Socket'。 </div><div class="line"><span class="bullet">7. </span>net.createConnection(path[, connectListener])</div><div class="line">创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 'connect' 事件。返回 'net.Socket'。 </div><div class="line"><span class="bullet">8. </span>net.isIP(input)</div><div class="line">检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。 </div><div class="line"><span class="bullet">9. </span>net.isIPv4(input)</div><div class="line">如果输入的地址为 IPV4， 返回 true，否则返回 false。 </div><div class="line"><span class="bullet">10. </span>net.isIPv6(input)</div><div class="line">如果输入的地址为 IPV6， 返回 true，否则返回 false。 </div><div class="line"></div><div class="line"><span class="code">    * net.Server</span></div><div class="line"><span class="code">        1. server.listen(port[, host][, backlog][, callback])</span></div><div class="line"><span class="code">        监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。 </span></div><div class="line"><span class="code">        2. server.listen(path[, callback])</span></div><div class="line"><span class="code">        通过指定 path 的连接，启动一个本地 socket 服务器。 </span></div><div class="line"><span class="code">        3. server.listen(handle[, callback])</span></div><div class="line"><span class="code">        通过指定句柄连接。 </span></div><div class="line"><span class="code">        4. server.listen(options[, callback])</span></div><div class="line"><span class="code">        options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。 </span></div><div class="line"><span class="code">        5. server.close([callback])</span></div><div class="line"><span class="code">        服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 'close' 事件。 </span></div><div class="line"><span class="code">        6. server.address()</span></div><div class="line"><span class="code">        操作系统返回绑定的地址，协议族名和服务器端口。 </span></div><div class="line"><span class="code">        7. server.unref()</span></div><div class="line"><span class="code">        如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。 </span></div><div class="line"><span class="code">        8. server.ref()</span></div><div class="line"><span class="code">        与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。 </span></div><div class="line"><span class="code">        9. server.getConnections(callback)</span></div><div class="line"><span class="code">        异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。 </span></div><div class="line"></div><div class="line"><span class="code">    * net.Socket</span></div><div class="line"><span class="code">        1. lookup</span></div><div class="line"><span class="code">        在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。 </span></div><div class="line"><span class="code">        2. connect</span></div><div class="line"><span class="code">        成功建立 socket 连接时触发。 </span></div><div class="line"><span class="code">        3. data</span></div><div class="line"><span class="code">        当接收到数据时触发。 </span></div><div class="line"><span class="code">        4. end</span></div><div class="line"><span class="code">        当 socket 另一端发送 FIN 包时，触发该事件。 </span></div><div class="line"><span class="code">        5. timeout</span></div><div class="line"><span class="code">        当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。 </span></div><div class="line"><span class="code">        6. drain</span></div><div class="line"><span class="code">        当写缓存为空得时候触发。可用来控制上传。 </span></div><div class="line"><span class="code">        7. error</span></div><div class="line"><span class="code">        错误发生时触发。 </span></div><div class="line"><span class="code">        8. close</span></div><div class="line"><span class="code">        当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。 </span></div><div class="line"></div><div class="line"></div><div class="line"><span class="section">## DNS</span></div><div class="line"><span class="bullet">1. </span>dns.lookup(hostname[, options], callback)</div><div class="line">将域名（比如 'runoob.com'）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。 </div><div class="line"><span class="bullet">2. </span>dns.lookupService(address, port, callback)</div><div class="line">使用 getnameinfo 解析传入的地址和端口为域名和服务。 </div><div class="line"><span class="bullet">3. </span>dns.resolve(hostname[, rrtype], callback)</div><div class="line">将一个域名（如 'runoob.com'）解析为一个 rrtype 指定记录类型的数组。 </div><div class="line"><span class="bullet">4. </span>dns.resolve4(hostname, callback)</div><div class="line">和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，['74.125.79.104', '74.125.79.105', '74.125.79.106']）。 </div><div class="line"><span class="bullet">5. </span>dns.resolve6(hostname, callback)</div><div class="line">和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询） </div><div class="line"><span class="bullet">6. </span>dns.resolveMx(hostname, callback)</div><div class="line">和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。 </div><div class="line"><span class="bullet">7. </span>dns.resolveTxt(hostname, callback)</div><div class="line">和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。 </div><div class="line"><span class="bullet">8. </span>dns.resolveSrv(hostname, callback)</div><div class="line">和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[&#123;'priority': 10, 'weight': 5, 'port': 21223, 'name': 'service.example.com'&#125;, ...]）。 </div><div class="line"><span class="bullet">9. </span>dns.resolveSoa(hostname, callback)</div><div class="line">和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。 </div><div class="line"><span class="bullet">10. </span>dns.resolveNs(hostname, callback)</div><div class="line">和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, ['ns1.example.com', 'ns2.example.com']）。 </div><div class="line"><span class="bullet">11. </span>dns.resolveCname(hostname, callback)</div><div class="line">和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, ['bar.example.com']）。 </div><div class="line"><span class="bullet">12. </span>dns.reverse(ip, callback)</div><div class="line">反向解析 IP 地址，指向该 IP 地址的域名数组。 </div><div class="line"><span class="bullet">13. </span>dns.getServers()</div><div class="line">返回一个用于当前解析的 IP 地址数组的字符串。 </div><div class="line"><span class="bullet">14. </span>dns.setServers(servers)</div><div class="line">指定一组 IP 地址作为解析服务器。 </div><div class="line"></div><div class="line"></div><div class="line"><span class="section">##Domain</span></div><div class="line">Node.js Domain(域) 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。引入 Domain 模块 语法格式如下：</div><div class="line"></div><div class="line"><span class="bullet">1. </span>domain.run(function)</div><div class="line"> 在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。 </div><div class="line"><span class="bullet">2. </span>domain.add(emitter)</div><div class="line">显式的增加事件 </div><div class="line"><span class="bullet">3. </span>domain.remove(emitter)</div><div class="line">删除事件。 </div><div class="line"><span class="bullet">4. </span>domain.bind(callback)</div><div class="line">返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的 error 事件。 </div><div class="line"><span class="bullet">5. </span>domain.intercept(callback)</div><div class="line">和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。 </div><div class="line"><span class="bullet">6. </span>domain.enter()</div><div class="line"> 进入一个异步调用的上下文，绑定到domain。 </div><div class="line"><span class="bullet">7. </span>domain.exit()</div><div class="line">退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。 </div><div class="line"><span class="bullet">8. </span>domain.dispose()</div><div class="line"> 释放一个domain对象，让node进程回收这部分资源。 </div><div class="line"><span class="bullet">9. </span>domain.create()</div><div class="line">返回一个domain对象。 </div><div class="line"></div><div class="line"></div><div class="line"><span class="section">node  web 模块</span></div><div class="line">=================</div><div class="line"><span class="section">## 使用 Node 创建 Web 服务器</span></div></pre></td></tr></table></figure>
<p>var http = require(‘http’);<br>var fs = require(‘fs’);<br>var url = require(‘url’);</p>
<p>// 创建服务器<br>http.createServer( function (request, response) {<br>   // 解析请求，包括文件名<br>   var pathname = url.parse(request.url).pathname;</p>
<p>   // 输出请求的文件名<br>   console.log(“Request for “ + pathname + “ received.”);</p>
<p>   // 从文件系统中读取请求的文件内容<br>   fs.readFile(pathname.substr(1), function (err, data) {<br>      if (err) {<br>         console.log(err);<br>         // HTTP 状态码: 404 : NOT FOUND<br>         // Content Type: text/plain<br>         response.writeHead(404, {‘Content-Type’: ‘text/html’});<br>      }else{<br>         // HTTP 状态码: 200 : OK<br>         // Content Type: text/plain<br>         response.writeHead(200, {‘Content-Type’: ‘text/html’});    </p>
<pre><code>   // 响应文件内容
   response.write(data.toString());        
}
//  发送响应数据
response.end();
</code></pre><p>   });<br>}).listen(8081);</p>
<p>// 控制台会输出以下信息<br>console.log(‘Server running at <a href="http://127.0.0.1:8081/" target="_blank" rel="external">http://127.0.0.1:8081/</a>‘);<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="vala"><span class="meta">## 使用 Node 创建 Web 客户端</span></span></div></pre></td></tr></table></figure></p>
<p>var http = require(‘http’);</p>
<p>// 用于请求的选项<br>var options = {<br>   host: ‘localhost’,<br>   port: ‘8081’,<br>   path: ‘/index.htm’<br>};</p>
<p>// 处理响应的回调函数<br>var callback = function(response){<br>   // 不断更新数据<br>   var body = ‘’;<br>   response.on(‘data’, function(data) {<br>      body += data;<br>   });</p>
<p>   response.on(‘end’, function() {<br>      // 数据接收完成<br>      console.log(body);<br>   });<br>}<br>// 向服务端发送请求<br>var req = http.request(options, callback);<br>req.end();<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="crmsh"><span class="keyword">Node</span>.<span class="title">js</span> Express 框架</span></div><div class="line">=====================</div><div class="line">Express 简介</div><div class="line"></div><div class="line">Express 是一个简洁而灵活的 <span class="keyword">node</span>.<span class="title">js</span> Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</div><div class="line"></div><div class="line">使用 Express 可以快速地搭建一个完整功能的网站。</div><div class="line"></div><div class="line">Express 框架核心特性：</div><div class="line"></div><div class="line">* 可以设置中间件来响应 HTTP 请求。</div><div class="line">* 定义了路由表用于执行不同的 HTTP 请求动作。 </div><div class="line">* 可以通过向模板传递参数来动态渲染 HTML 页面。</div><div class="line"></div><div class="line">&gt;   $ npm install express --save   </div><div class="line">    $ npm install body-parser --save  </div><div class="line">    $ npm install cookie-parser --save  </div><div class="line">    $ npm install multer --save  </div><div class="line"></div><div class="line">以上命令会将 Express 框架安装在当期目录的 <span class="keyword">node</span><span class="title">\_modules</span> 目录中， node_modules 目录下会自动创建 express 目录。以下几个重要的模块是需要与 express 框架一起安装的：</div><div class="line"></div><div class="line">body-parser - <span class="keyword">node</span>.<span class="title">js</span> 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</div><div class="line"></div><div class="line">cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</div><div class="line"></div><div class="line">multer - <span class="keyword">node</span>.<span class="title">js</span> 中间件，用于处理 <span class="attr">enctype=</span><span class="string">"multipart/form-data"</span>（设置表单的MIME编码）的表单数据。</div></pre></td></tr></table></figure></p>
<p>//express_demo.js 文件<br>var express = require(‘express’);<br>var app = express();</p>
<p>app.get(‘/‘, function (req, res) {<br>   res.send(‘Hello World’);<br>})</p>
<p>var server = app.listen(8081, function () {</p>
<p>  var host = server.address().address<br>  var port = server.address().port</p>
<p>  console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)</p>
<p>})<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="section">## request 和 response 对象的具体介绍：</span></div><div class="line"></div><div class="line"><span class="bullet">* </span>Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有： </div><div class="line"></div><div class="line"><span class="bullet">1. </span>req.app：当callback为外部文件时，用req.app访问express的实例</div><div class="line"><span class="bullet">2. </span>req.baseUrl：获取路由当前安装的URL路径</div><div class="line"><span class="bullet">3. </span>req.body / req.cookies：获得「请求主体」/ Cookies</div><div class="line"><span class="bullet">4. </span>req.fresh / req.stale：判断请求是否还「新鲜」</div><div class="line"><span class="bullet">5. </span>req.hostname / req.ip：获取主机名和IP地址</div><div class="line"><span class="bullet">6. </span>req.originalUrl：获取原始请求URL</div><div class="line"><span class="bullet">7. </span>req.params：获取路由的parameters</div><div class="line"><span class="bullet">8. </span>req.path：获取请求路径</div><div class="line"><span class="bullet">9. </span>req.protocol：获取协议类型</div><div class="line"><span class="bullet">10. </span>req.query：获取URL的查询参数串</div><div class="line"><span class="bullet">11. </span>req.route：获取当前匹配的路由</div><div class="line"><span class="bullet">12. </span>req.subdomains：获取子域名</div><div class="line"><span class="bullet">13. </span>req.accpets（）：检查请求的Accept头的请求类型</div><div class="line"><span class="bullet">14. </span>req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages</div><div class="line"><span class="bullet">15. </span>req.get（）：获取指定的HTTP请求头</div><div class="line"><span class="bullet">16. </span>req.is（）：判断请求头Content-Type的MIME类型</div><div class="line"></div><div class="line"><span class="bullet">* </span>Response 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：</div><div class="line"><span class="bullet">1. </span>res.app：同req.app一样</div><div class="line"><span class="bullet">2. </span>res.append（）：追加指定HTTP头</div><div class="line"><span class="bullet">3. </span>res.set（）在res.append（）后将重置之前设置的头</div><div class="line"><span class="bullet">4. </span>res.cookie（name，value [，option]）：设置Cookie</div><div class="line"><span class="bullet">5. </span>opition: domain / expires / httpOnly / maxAge / path / secure / signed</div><div class="line"><span class="bullet">6. </span>res.clearCookie（）：清除Cookie</div><div class="line"><span class="bullet">7. </span>res.download（）：传送指定路径的文件</div><div class="line"><span class="bullet">8. </span>res.get（）：返回指定的HTTP头</div><div class="line"><span class="bullet">9. </span>res.json（）：传送JSON响应</div><div class="line"><span class="bullet">10. </span>res.jsonp（）：传送JSONP响应</div><div class="line"><span class="bullet">11. </span>res.location（）：只设置响应的Location HTTP头，不设置状态码或者close response</div><div class="line"><span class="bullet">12. </span>res.redirect（）：设置响应的Location HTTP头，并且设置状态码302</div><div class="line"><span class="bullet">13. </span>res.send（）：传送HTTP响应</div><div class="line"><span class="bullet">14. </span>res.sendFile（path [，options] [，fn]）：传送指定路径的文件 -会自动根据文件extension设定Content-Type</div><div class="line"><span class="bullet">15. </span>res.set（）：设置HTTP头，传入object可以一次设置多个头</div><div class="line"><span class="bullet">16. </span>res.status（）：设置HTTP状态码</div><div class="line"><span class="bullet">17. </span>res.type（）：设置Content-Type的MIME类型</div><div class="line"></div><div class="line"><span class="section">## 路由</span></div></pre></td></tr></table></figure></p>
<p>var express = require(‘express’);<br>var app = express();</p>
<p>//  主页输出 “Hello World”<br>app.get(‘/‘, function (req, res) {<br>   console.log(“主页 GET 请求”);<br>   res.send(‘Hello GET’);<br>})</p>
<p>//  POST 请求<br>app.post(‘/‘, function (req, res) {<br>   console.log(“主页 POST 请求”);<br>   res.send(‘Hello POST’);<br>})</p>
<p>//  /del_user 页面响应<br>app.delete(‘/del_user’, function (req, res) {<br>   console.log(“/del_user 响应 DELETE 请求”);<br>   res.send(‘删除页面’);<br>})</p>
<p>//  /list_user 页面 GET 请求<br>app.get(‘/list_user’, function (req, res) {<br>   console.log(“/list_user GET 请求”);<br>   res.send(‘用户列表页面’);<br>})</p>
<p>// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求<br>app.get(‘/ab<em>cd’, function(req, res) {<br>   console.log(“/ab</em>cd GET 请求”);<br>   res.send(‘正则匹配’);<br>})</p>
<p>var server = app.listen(8081, function () {</p>
<p>  var host = server.address().address<br>  var port = server.address().port</p>
<p>  console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)</p>
<p>})<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="vala"><span class="meta">## 静态文件</span></span></div><div class="line">Express 提供了内置的中间件 express.<span class="keyword">static</span>  来设置静态文件如：图片， CSS, JavaScript 等。</div><div class="line"></div><div class="line">你可以使用 express.<span class="keyword">static</span>  中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 <span class="keyword">public</span> 目录下，你可以这么写：</div><div class="line"></div><div class="line"></div><div class="line">&gt; app.use(express.<span class="keyword">static</span>(<span class="string">'public'</span>));</div><div class="line"></div><div class="line"><span class="meta">## 获取 GET 方法参数</span></div></pre></td></tr></table></figure></p>
<p>var express = require(‘express’);<br>var app = express();</p>
<p>app.use(express.static(‘public’));</p>
<p>app.get(‘/index.htm’, function (req, res) {<br>   res.sendFile( __dirname + “/“ + “index.htm” );<br>})</p>
<p>app.get(‘/process_get’, function (req, res) {</p>
<p>   // 输出 JSON 格式<br>   response = {<br>       first_name:req.query.first_name,<br>       last_name:req.query.last_name<br>   };<br>   console.log(response);<br>   res.end(JSON.stringify(response));<br>})</p>
<p>var server = app.listen(8081, function () {</p>
<p>  var host = server.address().address<br>  var port = server.address().port</p>
<p>  console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)</p>
<p>})<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">## 获取 POST 方法参数</span></div></pre></td></tr></table></figure></p>
<p>var express = require(‘express’);<br>var app = express();<br>var bodyParser = require(‘body-parser’);</p>
<p>// 创建 application/x-www-form-urlencoded 编码解析<br>var urlencodedParser = bodyParser.urlencoded({ extended: false })</p>
<p>app.use(express.static(‘public’));</p>
<p>app.get(‘/index.htm’, function (req, res) {<br>   res.sendFile( __dirname + “/“ + “index.htm” );<br>})</p>
<p>app.post(‘/process_post’, urlencodedParser, function (req, res) {</p>
<p>   // 输出 JSON 格式<br>   response = {<br>       first_name:req.body.first_name,<br>       last_name:req.body.last_name<br>   };<br>   console.log(response);<br>   res.end(JSON.stringify(response));<br>})</p>
<p>var server = app.listen(8081, function () {</p>
<p>  var host = server.address().address<br>  var port = server.address().port</p>
<p>  console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)</p>
<p>})<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">## 文件上传</span></div></pre></td></tr></table></figure></p>
<p>var express = require(‘express’);<br>var app = express();<br>var fs = require(“fs”);</p>
<p>var bodyParser = require(‘body-parser’);<br>var multer  = require(‘multer’);</p>
<p>app.use(express.static(‘public’));<br>app.use(bodyParser.urlencoded({ extended: false }));<br>app.use(multer({ dest: ‘/tmp/‘}).array(‘image’));</p>
<p>app.get(‘/index.htm’, function (req, res) {<br>   res.sendFile( __dirname + “/“ + “index.htm” );<br>})</p>
<p>app.post(‘/file_upload’, function (req, res) {</p>
<p>   console.log(req.files[0]);  // 上传的文件信息</p>
<p>   var des_file = __dirname + “/“ + req.files[0].originalname;<br>   fs.readFile( req.files[0].path, function (err, data) {<br>        fs.writeFile(des_file, data, function (err) {<br>         if( err ){<br>              console.log( err );<br>         }else{<br>               response = {<br>                   message:’File uploaded successfully’,<br>                   filename:req.files[0].originalname<br>              };<br>          }<br>          console.log( response );<br>          res.end( JSON.stringify( response ) );<br>       });<br>   });<br>})</p>
<p>var server = app.listen(8081, function () {</p>
<p>  var host = server.address().address<br>  var port = server.address().port</p>
<p>  console.log(“应用实例，访问地址为 <a href="http://%s:%s" target="_blank" rel="external">http://%s:%s</a>“, host, port)</p>
<p>})<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="vala"><span class="meta">## Cookie 管理</span></span></div></pre></td></tr></table></figure></p>
<p>// express_cookie.js 文件<br>var express      = require(‘express’)<br>var cookieParser = require(‘cookie-parser’)</p>
<p>var app = express()<br>app.use(cookieParser())</p>
<p>app.get(‘/‘, function(req, res) {<br>  console.log(“Cookies: “, req.cookies)<br>})</p>
<p>app.listen(8081)<br>```</p>
<h1 id="npm-命令"><a href="#npm-命令" class="headerlink" title="npm 命令"></a>npm 命令</h1><ol>
<li><p>npm install express  安装express模块</p>
<ul>
<li>默认在当前目录产生 node_modules 目录 下</li>
<li>-g : npm install -g express<br>  安装到node程序目录下的 node_modules 目录 下</li>
<li>npm get global : 查看是否使用全局模式 返回 true/false</li>
<li>npm install express@3.0.6 : 指定模块安装版本</li>
<li>全局安装时供命令行使用的 , require() 是无法导入的</li>
<li>–save : 将安装信息写入 package.json 中, 类似 pip 的requirement 文件<br>  npm install express –save : 安装express模块并记录到package.json 文件中<br>  推送到github 时就不需要 node_modules 目录了<br>  npm install : 安装 package.json 记录的依赖 类似 pip install -r requirement.txt</li>
</ul>
</li>
<li><p>npm init : 创建 package.json 包文件</p>
<ul>
<li>包的入口 main 字段指定, 没有则会寻找 index.js 或者 index.node  。 类似 python 的 <code>__init__.py</code></li>
<li>.npmignore 忽略掉不发布到npm的文件</li>
</ul>
</li>
<li><p>npm view express :  查看模块的package.json 包</p>
</li>
<li><p>npm list : 查看当前目录下安装的 node 包</p>
</li>
<li><p>npm view moudleName dependencies：查看包的依赖关系</p>
</li>
<li><p>npm view moduleName repository.url：查看包的源文件地址</p>
</li>
<li><p>npm view moduleName engines：查看包所依赖的Node的版本</p>
</li>
<li><p>npm help folders：查看npm使用的所有文件夹</p>
</li>
<li><p>npm rebuild moduleName：用于更改包内容后进行重建</p>
</li>
<li><p>npm outdated：检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新</p>
</li>
<li><p>npm update moduleName：更新node模块</p>
</li>
<li><p>npm uninstall moudleName：卸载node模块</p>
</li>
<li><p>一个npm包是包含了package.json的文件夹，package.json描述了这个文件夹的结构。访问npm的json文件夹的方法如下：<br>$ npm help json<br>此命令会以默认的方式打开一个网页，如果更改了默认打开程序则可能不会以网页的形式打开。</p>
</li>
<li><p>发布一个npm包的时候，需要检验某个包名是否已存在<br>$ npm search packageName</p>
</li>
<li><p>npm init：会引导你创建一个package.json文件，包括名称. 版本. 作者这些信息等</p>
</li>
<li><p>npm root：查看当前包的安装路径<br>npm root -g：查看全局的包的安装路径</p>
</li>
<li><p>npm -v：查看npm安装的版本</p>
</li>
</ol>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><ul>
<li>使用流程 <ol>
<li>git clone 下来 </li>
<li>npm install : 安装依赖包</li>
<li>确认有themes 目录 hexo  生成页面需要用到<br>如果没有用hexo init 生成</li>
</ol>
</li>
<li><p>或者是 </p>
<ol>
<li>hexo init :  得到hexo环境</li>
<li>另外目录 git clone  得到代码仓库</li>
<li>复制 .git 目录到 hexo 环境中</li>
<li>检出仓库中的文件</li>
</ol>
</li>
<li><p>在执行 hexo deploy 后,出现 error deployer not found:git 的错误</p>
</li>
</ul>
<p><code>npm install hexo-deployer-git --save</code>改了之后执行，然后再部署试试</p>
<ul>
<li>没有 <code>hexo server</code> 命令 </li>
</ul>
<p><code>npm install hexo-server --save</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hongdaorongthink.github.io/2016/07/21/node的使用/" data-id="cirou3vtm000da8m3b3fewgsw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/">node</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/24/使用virtualenv遇到bug/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          使用virtualenv遇到bug
        
      </div>
    </a>
  
  
    <a href="/2016/07/20/2016年7月20日/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2016年7月20日</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/antlr/">antlr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chrome/">chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crontab/">crontab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/easyui/">easyui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/plan/">plan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quartz/">quartz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/work/">work</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/书签/">书签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/定时任务/">定时任务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据分析/">数据分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法解析/">语法解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/金仕达/">金仕达</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/antlr/" style="font-size: 10px;">antlr</a> <a href="/tags/bug/" style="font-size: 10px;">bug</a> <a href="/tags/c/" style="font-size: 13.33px;">c++</a> <a href="/tags/chrome/" style="font-size: 10px;">chrome</a> <a href="/tags/crontab/" style="font-size: 10px;">crontab</a> <a href="/tags/easyui/" style="font-size: 10px;">easyui</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/plan/" style="font-size: 10px;">plan</a> <a href="/tags/python/" style="font-size: 16.67px;">python</a> <a href="/tags/quartz/" style="font-size: 16.67px;">quartz</a> <a href="/tags/work/" style="font-size: 13.33px;">work</a> <a href="/tags/书签/" style="font-size: 10px;">书签</a> <a href="/tags/定时任务/" style="font-size: 13.33px;">定时任务</a> <a href="/tags/数据分析/" style="font-size: 10px;">数据分析</a> <a href="/tags/语法解析/" style="font-size: 10px;">语法解析</a> <a href="/tags/金仕达/" style="font-size: 10px;">金仕达</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/10/收藏夹/">收藏夹</a>
          </li>
        
          <li>
            <a href="/2016/08/08/antlr4/">antlr4</a>
          </li>
        
          <li>
            <a href="/2016/08/08/学习框架/">学习框架</a>
          </li>
        
          <li>
            <a href="/2016/08/03/科学计算/">科学计算</a>
          </li>
        
          <li>
            <a href="/2016/08/01/写一个简单服务框架/">写一个简单服务框架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 HongDR<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>